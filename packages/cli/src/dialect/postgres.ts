import { PostgresDialect, sql } from "kysely";
import { Pool } from "pg";
import { PostgreSqlContainer } from "@testcontainers/postgresql";
import {
  ConstraintAttributes,
  IndexAttributes,
  IntrospectProps,
  KyrageDialect,
} from "./types";
import { DBClient, PlannableKysely } from "../client";
import { ReferentialActions } from "../operation";
import * as R from "ramda";
import { ConfigValue } from "../config/loader";

export class PostgresKyrageDialect implements KyrageDialect {
  getName() {
    return "postgres" as const;
  }

  getDevDatabaseImageName() {
    return "postgres:16";
  }

  createKyselyDialect(connectionString: string) {
    return new PostgresDialect({
      pool: new Pool({ connectionString }),
    });
  }

  createIntrospectionDriver(client: DBClient) {
    return {
      convertTypeName: convertPSQLTypeName,
      introspect: doPSQLintrospect(client),
    };
  }

  createDevDatabaseContainer(image: string) {
    return new PostgreSqlContainer(image);
  }
}

export const doPSQLintrospect =
  (client: DBClient) => async (props: IntrospectProps) => {
    await using db = client.getDB();
    const [tables, indexes, constraints] = await Promise.all([
      introspectPSQLTables(db),
      introspectPSQLIndexes(db),
      introspectPSQLConstraints(db),
    ]);
    const {
      indexes: normalizedIndexes,
      uniqueConstraints: normalizedUniqueConstraints,
    } = computeAutoGeneratedIndexesAndConstraints(props.config, {
      indexes,
      constraints,
    });

    return {
      tables,
      indexes: normalizedIndexes,
      constraints: {
        ...constraints,
        unique: normalizedUniqueConstraints,
      },
    };
  };

/*
 * Some PSQL compliant database automatically creates unique constraints for unique indexes, and vice versa (e.g., CockroachDB),
 * and there is no way to distinguish between automatically generated unique constraints and user-defined unique constraints.
 * This function searches for user-defined unique constraints and indexes in the configuration and adopts what is present in the configuration.
 * If neither exists, it treats them as a difference.
 */
export const computeAutoGeneratedIndexesAndConstraints = (
  config: ConfigValue,
  props: {
    indexes: IndexAttributes;
    constraints: ConstraintAttributes;
  }
) => {
  const sameNameOnTable =
    (t: ReadonlyArray<unknown>) => (c: { name: string; table: string }) =>
      R.any(R.whereEq({ name: c.name, table: c.table }), t);
  const [adoptedUniqueConstraints, unconfiguredUniqueConstraints] = R.partition(
    sameNameOnTable(config.uniqueConstraints),
    props.constraints.unique
  );
  const [adoptedUniqueIndexes, unconfiguredUniqueIndexes] = R.partition(
    sameNameOnTable(config.indexes),
    props.indexes
  );
  const unrelatedUniqueConstraints = R.reject(
    sameNameOnTable(adoptedUniqueIndexes),
    unconfiguredUniqueConstraints
  );
  const unrelatedUniqueIndexes = R.reject(
    sameNameOnTable(adoptedUniqueConstraints),
    unconfiguredUniqueIndexes
  );

  return {
    indexes: [...adoptedUniqueIndexes, ...unrelatedUniqueIndexes],
    uniqueConstraints: [
      ...adoptedUniqueConstraints,
      ...unrelatedUniqueConstraints,
    ],
  };
};

/*
 * Convert PostgreSQL type names to more general SQL type names.
 */
export const convertPSQLTypeName = (typeName: string) => {
  const nameDict = {
    bool: "boolean",
    int2: "smallint",
    int4: "integer",
    int8: "bigint",
  };

  return nameDict[typeName as keyof typeof nameDict] ?? typeName;
};

export const introspectPSQLTables = async (db: PlannableKysely) => {
  const { rows } = await sql`
    SELECT
      n.nspname AS table_schema,
      c.relname AS table_name,
      a.attname AS column_name,
      pg_get_expr(d.adbin, d.adrelid) AS column_default,
      CASE 
        WHEN t.typname = 'varchar' OR t.typname = 'char' THEN a.atttypmod - 4
        ELSE NULL 
      END AS character_maximum_length
    FROM pg_class c
    JOIN pg_namespace n ON n.oid = c.relnamespace
    JOIN pg_attribute a ON a.attrelid = c.oid
    LEFT JOIN pg_attrdef d ON d.adrelid = c.oid AND d.adnum = a.attnum
    JOIN pg_type t ON t.oid = a.atttypid
    WHERE c.relkind = 'r'
      AND n.nspname = 'public'
      AND a.attnum > 0
      AND NOT a.attisdropped
    ORDER BY c.relname, a.attnum;
  `
    .$castTo<PostgresColumnInfo>()
    .execute(db);

  return rows.map((row) => ({
    schema: row.table_schema,
    table: row.table_name,
    name: row.column_name,
    default: row.column_default,
    characterMaximumLength: row.character_maximum_length
      ? // NOTE: PostgreSQL returns character_maximum_length as a number, but CockroachDB does not.
        Number(row.character_maximum_length)
      : null,
  }));
};

type PostgresColumnInfo = {
  table_schema: string;
  table_name: string;
  column_name: string;
  column_default: string | null;
  character_maximum_length: number | null;
};

export const introspectPSQLIndexes = async (db: PlannableKysely) => {
  const { rows } = await sql`
    SELECT
      t.relname AS table_name,
      c.relname AS index_name,
      i.indisunique AS is_unique,
      jsonb_agg(a.attname ORDER BY array_position(i.indkey, a.attnum)) AS column_names
    FROM pg_class t
    JOIN pg_namespace n ON n.oid = t.relnamespace
    JOIN pg_index i ON i.indrelid = t.oid
    JOIN pg_class c ON c.oid = i.indexrelid
    JOIN pg_attribute a ON a.attrelid = t.oid AND a.attnum = ANY (i.indkey)
    WHERE t.relkind = 'r'
      AND n.nspname = 'public'
      AND NOT i.indisprimary
    GROUP BY t.relname, c.relname, i.indisunique, i.indisprimary, c.oid;
  `
    .$castTo<PostgresIndexInfo>()
    .execute(db);
  return rows.map((r) => ({
    table: r.table_name,
    name: r.index_name,
    columns: r.column_names,
    unique: r.is_unique,
  }));
};

type PostgresIndexInfo = {
  table_name: string;
  index_name: string;
  is_unique: boolean;
  column_names: ReadonlyArray<string>;
};

export const introspectPSQLConstraints = async (db: PlannableKysely) => {
  const { rows } = await sql`
    SELECT
      n.nspname AS schema,
      t.relname AS table,
      c.conname AS name,
      CASE c.contype
          WHEN 'p' THEN 'PRIMARY KEY'
          WHEN 'u' THEN 'UNIQUE'
          WHEN 'f' THEN 'FOREIGN KEY'
      END AS type,
      jsonb_agg(a.attname ORDER BY array_position(c.conkey, a.attnum)) AS columns,
      -- Foreign Key専用の情報
      CASE 
          WHEN c.contype = 'f' THEN rt.relname 
          ELSE NULL 
      END AS referenced_table,
      CASE 
          WHEN c.contype = 'f' THEN jsonb_agg(ra.attname ORDER BY array_position(c.confkey, ra.attnum))
          ELSE NULL 
      END AS referenced_columns,
      CASE 
          WHEN c.contype = 'f' THEN 
              CASE c.confdeltype
                  WHEN 'c' THEN 'cascade'
                  WHEN 'n' THEN 'set null'
                  WHEN 'd' THEN 'set default'
                  WHEN 'r' THEN 'restrict'
                  WHEN 'a' THEN 'no action'
              END
          ELSE NULL
      END AS on_delete,
      CASE 
          WHEN c.contype = 'f' THEN 
              CASE c.confupdtype
                  WHEN 'c' THEN 'cascade'
                  WHEN 'n' THEN 'set null'
                  WHEN 'd' THEN 'set default'
                  WHEN 'r' THEN 'restrict'
                  WHEN 'a' THEN 'no action'
              END
          ELSE NULL
      END AS on_update
    FROM pg_constraint c
    JOIN pg_class t ON c.conrelid = t.oid
    JOIN pg_namespace n ON t.relnamespace = n.oid
    JOIN pg_attribute a ON a.attrelid = t.oid AND a.attnum = ANY(c.conkey)
    -- Foreign Key用のJOIN
    LEFT JOIN pg_class rt ON c.confrelid = rt.oid
    LEFT JOIN pg_attribute ra ON ra.attrelid = c.confrelid AND ra.attnum = ANY(c.confkey)
    WHERE c.contype IN ('p', 'u', 'f')  -- primary key, unique, foreign key constraints
        AND n.nspname = 'public'
        AND NOT a.attisdropped
        AND (c.contype != 'f' OR NOT ra.attisdropped)  -- Foreign Key用の条件
    GROUP BY n.nspname, t.relname, c.conname, c.contype, c.oid, c.conkey, t.oid, 
              rt.relname, c.confkey, c.confdeltype, c.confupdtype
    ORDER BY t.relname, c.conname;
  `
    .$castTo<PostgresConstraint>()
    .execute(db);

  return {
    primaryKey: rows.filter((row) => row.type === "PRIMARY KEY"),
    unique: rows.filter((row) => row.type === "UNIQUE"),
    foreignKey: rows
      .filter((row) => row.type === "FOREIGN KEY")
      .map((row) => {
        const {
          referenced_table: referencedTable,
          referenced_columns: referencedColumns,
          on_delete: onDelete,
          on_update: onUpdate,
          ...columns
        } = row;

        return {
          ...columns,
          referencedTable,
          referencedColumns,
          onDelete,
          onUpdate,
        };
      }),
  };
};

type PostgresConstraintBase = {
  schema: string;
  table: string;
  name: string;
  columns: ReadonlyArray<string>;
};

type PostgresForeignKeyConstraint = {
  referenced_table: string;
  referenced_columns: ReadonlyArray<string>;
  on_delete?: ReferentialActions;
  on_update?: ReferentialActions;
};

type PostgresConstraint =
  | (PostgresConstraintBase & {
      type: "PRIMARY KEY";
    })
  | (PostgresConstraintBase & {
      type: "UNIQUE";
    })
  | (PostgresConstraintBase &
      PostgresForeignKeyConstraint & {
        type: "FOREIGN KEY";
      });
