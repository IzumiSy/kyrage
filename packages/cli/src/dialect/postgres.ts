import { PostgresDialect, sql } from "kysely";
import { Pool } from "pg";
import { PostgreSqlContainer } from "@testcontainers/postgresql";
import { IntrospectProps, KyrageDialect } from "./types";
import { DBClient, PlannableKysely } from "../client";
import {
  computeAutoGeneratedIndexesAndConstraints,
  introspectGenericConstraints,
  introspectGenericTables,
} from "./shared";

export class PostgresKyrageDialect implements KyrageDialect {
  getName() {
    return "postgres" as const;
  }

  getDevDatabaseImageName() {
    return "postgres:16";
  }

  createKyselyDialect(connectionString: string) {
    return new PostgresDialect({
      pool: new Pool({ connectionString }),
    });
  }

  createIntrospectionDriver(client: DBClient) {
    return {
      convertTypeName: convertPSQLTypeName,
      introspect: doPSQLintrospect(client),
    };
  }

  createDevDatabaseContainer(image: string) {
    return new PostgreSqlContainer(image);
  }
}

export const doPSQLintrospect =
  (client: DBClient) => async (props: IntrospectProps) => {
    await using db = client.getDB();
    const [tables, constraints, indexes] = await Promise.all([
      introspectGenericTables(db),
      introspectGenericConstraints(db),
      introspectPSQLIndexes(db),
    ]);
    const {
      indexes: normalizedIndexes,
      uniqueConstraints: normalizedUniqueConstraints,
    } = computeAutoGeneratedIndexesAndConstraints(props.config, {
      indexes,
      constraints,
    });

    return {
      tables,
      indexes: normalizedIndexes,
      constraints: {
        ...constraints,
        unique: normalizedUniqueConstraints,
      },
    };
  };

/*
 * Convert PostgreSQL type names to more general SQL type names.
 */
export const convertPSQLTypeName = (typeName: string) => {
  const nameDict = {
    bool: "boolean",
    int2: "smallint",
    int4: "integer",
    int8: "bigint",
  };

  return nameDict[typeName as keyof typeof nameDict] ?? typeName;
};

export const introspectPSQLIndexes = async (db: PlannableKysely) => {
  const { rows } = await sql`
    SELECT
      t.relname AS table_name,
      c.relname AS index_name,
      i.indisunique AS is_unique,
      jsonb_agg(a.attname ORDER BY array_position(i.indkey, a.attnum)) AS column_names
    FROM pg_class t
    JOIN pg_namespace n ON n.oid = t.relnamespace
    JOIN pg_index i ON i.indrelid = t.oid
    JOIN pg_class c ON c.oid = i.indexrelid
    JOIN pg_attribute a ON a.attrelid = t.oid AND a.attnum = ANY (i.indkey)
    WHERE t.relkind = 'r'
      AND n.nspname = 'public'
      AND NOT i.indisprimary
    GROUP BY t.relname, c.relname, i.indisunique, i.indisprimary, c.oid;
  `
    .$castTo<PostgresIndex>()
    .execute(db);
  return rows.map((r) => ({
    table: r.table_name,
    name: r.index_name,
    columns: r.column_names,
    unique: r.is_unique,
  }));
};

type PostgresIndex = {
  table_name: string;
  index_name: string;
  is_unique: boolean;
  column_names: ReadonlyArray<string>;
};
