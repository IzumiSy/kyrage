import { MysqlDialect, sql } from "kysely";
import { createPool } from "mysql2";
import { MySqlContainer } from "@testcontainers/mysql";
import { IntrospectProps, KyrageDialect } from "./types";
import { DBClient, PlannableKysely } from "../client";
import { ReferentialActions } from "../operations/shared/types";
import { computeAutoGeneratedIndexesAndConstraints } from "./shared";
import {
  buildContainerDevDatabaseConfigSchema,
  ContainerDevDatabaseProvider,
  hasRunningDevStartContainer,
} from "../dev/providers/container";

export class MysqlKyrageDialect implements KyrageDialect {
  getName() {
    return "mysql" as const;
  }

  createKyselyDialect(connectionString: string) {
    return new MysqlDialect({
      pool: createPool(connectionString),
    });
  }

  createIntrospectionDriver(client: DBClient) {
    return {
      convertTypeName: convertMysqlTypeName,
      introspect: doMysqlIntrospect(client),
    };
  }

  createDevDatabaseProvider() {
    return new ContainerDevDatabaseProvider(
      this.getName(),
      (image) => new MySqlContainer(image)
    );
  }

  parseDevDatabaseConfig(config: unknown) {
    return buildContainerDevDatabaseConfigSchema({
      defaultImage: "mysql:8",
    }).parse(config);
  }

  async hasReusableDevDatabase(): Promise<boolean> {
    return hasRunningDevStartContainer(this.getName());
  }
}

export const doMysqlIntrospect =
  (client: DBClient) => async (props: IntrospectProps) => {
    await using db = client.getDB();
    const [tables, indexes, constraints] = await Promise.all([
      introspectMysqlTables(db),
      introspectMysqlIndexes(db),
      introspectMysqlConstraints(db),
    ]);
    const {
      indexes: normalizedIndexes,
      uniqueConstraints: normalizedUniqueConstraints,
    } = computeAutoGeneratedIndexesAndConstraints(props.config, {
      indexes,
      constraints,
    });

    return {
      tables,
      indexes: normalizedIndexes,
      constraints: {
        ...constraints,
        unique: normalizedUniqueConstraints,
      },
    };
  };

/*
 * Convert MySQL type names to more general SQL type names.
 */
export const convertMysqlTypeName = (typeName: string) => {
  const nameDict = {
    tinyint: "boolean",
    int: "integer",
  };

  return nameDict[typeName as keyof typeof nameDict] ?? typeName;
};

export const introspectMysqlTables = async (db: PlannableKysely) => {
  const { rows } = await sql`
    SELECT
      TABLE_SCHEMA as table_schema,
      TABLE_NAME as table_name,
      COLUMN_NAME as column_name,
      COLUMN_DEFAULT as column_default,
      CHARACTER_MAXIMUM_LENGTH as character_maximum_length
    FROM information_schema.COLUMNS
    WHERE TABLE_SCHEMA = DATABASE()
    ORDER BY TABLE_NAME, ORDINAL_POSITION;
  `
    .$castTo<MysqlColumnInfo>()
    .execute(db);

  return rows.map((row) => ({
    schema: row.table_schema,
    table: row.table_name,
    name: row.column_name,
    default: row.column_default,
    characterMaximumLength: row.character_maximum_length
      ? Number(row.character_maximum_length)
      : null,
  }));
};

type MysqlColumnInfo = {
  table_schema: string;
  table_name: string;
  column_name: string;
  column_default: string | null;
  character_maximum_length: number | null;
};

export const introspectMysqlIndexes = async (db: PlannableKysely) => {
  const { rows } = await sql`
    SELECT
      s.TABLE_NAME as table_name,
      s.INDEX_NAME as index_name,
      s.NON_UNIQUE = 0 as is_unique,
      GROUP_CONCAT(s.COLUMN_NAME ORDER BY s.SEQ_IN_INDEX) as column_names
    FROM information_schema.STATISTICS s
    WHERE s.TABLE_SCHEMA = DATABASE()
      AND s.INDEX_NAME != 'PRIMARY'
    GROUP BY s.TABLE_NAME, s.INDEX_NAME, s.NON_UNIQUE;
  `
    .$castTo<MysqlIndexInfo>()
    .execute(db);
  return rows.map((r) => ({
    table: r.table_name,
    name: r.index_name,
    columns: (r.column_names as unknown as string).split(','),
    unique: Boolean(r.is_unique),
  }));
};

type MysqlIndexInfo = {
  table_name: string;
  index_name: string;
  is_unique: number;
  column_names: ReadonlyArray<string>;
};

export const introspectMysqlConstraints = async (db: PlannableKysely) => {
  const { rows } = await sql`
    SELECT
      tc.TABLE_SCHEMA as schema_name,
      tc.TABLE_NAME as table_name,
      tc.CONSTRAINT_NAME as constraint_name,
      tc.CONSTRAINT_TYPE as constraint_type,
      GROUP_CONCAT(kcu.COLUMN_NAME ORDER BY kcu.ORDINAL_POSITION) as columns,
      -- Foreign Key specific information
      kcu.REFERENCED_TABLE_NAME as referenced_table,
      rc.UPDATE_RULE as on_update,
      rc.DELETE_RULE as on_delete,
      GROUP_CONCAT(kcu.REFERENCED_COLUMN_NAME ORDER BY kcu.ORDINAL_POSITION) as referenced_columns
    FROM information_schema.TABLE_CONSTRAINTS tc
    JOIN information_schema.KEY_COLUMN_USAGE kcu
      ON tc.CONSTRAINT_NAME = kcu.CONSTRAINT_NAME
      AND tc.TABLE_SCHEMA = kcu.TABLE_SCHEMA
      AND tc.TABLE_NAME = kcu.TABLE_NAME
    LEFT JOIN information_schema.REFERENTIAL_CONSTRAINTS rc
      ON tc.CONSTRAINT_NAME = rc.CONSTRAINT_NAME
      AND tc.TABLE_SCHEMA = rc.CONSTRAINT_SCHEMA
    WHERE tc.TABLE_SCHEMA = DATABASE()
      AND tc.CONSTRAINT_TYPE IN ('PRIMARY KEY', 'UNIQUE', 'FOREIGN KEY')
    GROUP BY tc.TABLE_SCHEMA, tc.TABLE_NAME, tc.CONSTRAINT_NAME, tc.CONSTRAINT_TYPE,
             kcu.REFERENCED_TABLE_NAME, rc.UPDATE_RULE, rc.DELETE_RULE
    ORDER BY tc.TABLE_NAME, tc.CONSTRAINT_NAME;
  `
    .$castTo<MysqlConstraint & { referenced_columns: string | null }>()
    .execute(db);

  return {
    primaryKey: rows
      .filter((row) => row.constraint_type === "PRIMARY KEY")
      .map((row) => ({
        schema: row.schema_name,
        table: row.table_name,
        name: row.constraint_name,
        type: "PRIMARY KEY" as const,
        columns: (row.columns as unknown as string).split(','),
      })),
    unique: rows
      .filter((row) => row.constraint_type === "UNIQUE")
      .map((row) => ({
        schema: row.schema_name,
        table: row.table_name,
        name: row.constraint_name,
        type: "UNIQUE" as const,
        columns: (row.columns as unknown as string).split(','),
      })),
    foreignKey: rows
      .filter((row) => row.constraint_type === "FOREIGN KEY")
      .map((row) => ({
        schema: row.schema_name,
        table: row.table_name,
        name: row.constraint_name,
        type: "FOREIGN KEY" as const,
        columns: (row.columns as unknown as string).split(','),
        referencedTable: row.referenced_table!,
        referencedColumns: row.referenced_columns 
          ? row.referenced_columns.split(',')
          : [],
        onDelete: convertMysqlReferentialAction(row.on_delete),
        onUpdate: convertMysqlReferentialAction(row.on_update),
      })),
  };
};

type MysqlConstraint = {
  schema_name: string;
  table_name: string;
  constraint_name: string;
  constraint_type: "PRIMARY KEY" | "UNIQUE" | "FOREIGN KEY";
  columns: ReadonlyArray<string>;
  referenced_table: string | null;
  on_delete: string | null;
  on_update: string | null;
};

export const convertMysqlReferentialAction = (
  action: string | null
): ReferentialActions | undefined => {
  if (!action) return undefined;
  
  const actionMap: Record<string, ReferentialActions> = {
    CASCADE: "cascade",
    "SET NULL": "set null",
    "SET DEFAULT": "set default",
    RESTRICT: "restrict",
    "NO ACTION": "no action",
  };
  
  return actionMap[action];
};
