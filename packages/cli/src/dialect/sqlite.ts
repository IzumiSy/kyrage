import { SqliteDialect, sql } from "kysely";
import Database from "better-sqlite3";
import { IntrospectProps, KyrageDialect } from "./types";
import { DBClient, PlannableKysely } from "../client";
import { computeAutoGeneratedIndexesAndConstraints } from "./shared";
import {
  buildFileDevDatabaseConfig,
  FileDevDatabaseProvider,
} from "../dev/providers/file";
import { ReferentialActions } from "../operations/shared/types";

export class SQLiteKyrageDialect implements KyrageDialect {
  getName() {
    return "sqlite" as const;
  }

  createKyselyDialect(connectionString: string) {
    return new SqliteDialect({
      database: new Database(connectionString),
    });
  }

  createIntrospectionDriver(client: DBClient) {
    return {
      convertTypeName: convertSQLiteTypeName,
      introspect: doSQLiteIntrospect(client),
    };
  }

  createDevDatabaseProvider() {
    return new FileDevDatabaseProvider();
  }

  parseDevDatabaseConfig(config: unknown) {
    // SQLite supports file-based dev databases only
    return buildFileDevDatabaseConfig().parse(config);
  }

  async hasReusableDevDatabase(): Promise<boolean> {
    // File-based dialects don't support reusable dev databases
    return false;
  }
}

export const doSQLiteIntrospect =
  (client: DBClient) => async (props: IntrospectProps) => {
    await using db = client.getDB();
    const [tables, indexes, constraints] = await Promise.all([
      introspectSQLiteTables(db),
      introspectSQLiteIndexes(db),
      introspectSQLiteConstraints(db),
    ]);
    const {
      indexes: normalizedIndexes,
      uniqueConstraints: normalizedUniqueConstraints,
    } = computeAutoGeneratedIndexesAndConstraints(props.config, {
      indexes,
      constraints,
    });

    return {
      tables,
      indexes: normalizedIndexes,
      constraints: {
        ...constraints,
        unique: normalizedUniqueConstraints,
      },
    };
  };

/*
 * Convert SQLite type names to more general SQL type names.
 */
export const convertSQLiteTypeName = (typeName: string) => {
  const nameDict = {
    INTEGER: "integer",
    TEXT: "text",
    REAL: "real",
    BLOB: "blob",
    NUMERIC: "numeric",
  };

  return (
    nameDict[typeName.toUpperCase() as keyof typeof nameDict] ??
    typeName.toLowerCase()
  );
};

export const introspectSQLiteTables = async (db: PlannableKysely) => {
  // Get list of tables excluding sqlite system tables
  const { rows: tables } = await sql`
    SELECT name FROM sqlite_master 
    WHERE type = 'table' 
    AND name NOT LIKE 'sqlite_%'
    AND name != 'kysely_migration'
    AND name != 'kysely_migration_lock'
  `
    .$castTo<{ name: string }>()
    .execute(db);

  const tableInfos = [];

  for (const table of tables) {
    // Get column information for each table using PRAGMA table_info
    const { rows: columns } = await sql`
      SELECT * FROM pragma_table_info(${table.name})
    `
      .$castTo<SQLiteColumnInfo>()
      .execute(db);

    tableInfos.push(
      ...columns.map((col) => ({
        schema: "main", // SQLite default schema
        table: table.name,
        name: col.name,
        default: col.dflt_value,
        characterMaximumLength: null, // SQLite doesn't enforce string length limits
      }))
    );
  }

  return tableInfos;
};

type SQLiteColumnInfo = {
  cid: number;
  name: string;
  type: string;
  notnull: number;
  dflt_value: string | null;
  pk: number;
};

export const introspectSQLiteIndexes = async (db: PlannableKysely) => {
  const { rows: tables } = await sql`
    SELECT name FROM sqlite_master 
    WHERE type = 'table' 
    AND name NOT LIKE 'sqlite_%'
    AND name != 'kysely_migration'
    AND name != 'kysely_migration_lock'
  `
    .$castTo<{ name: string }>()
    .execute(db);

  const indexes = [];

  for (const table of tables) {
    const { rows: indexList } = await sql`
      SELECT * FROM pragma_index_list(${table.name})
    `
      .$castTo<SQLiteIndexList>()
      .execute(db);

    for (const index of indexList) {
      // Only include indexes created by CREATE INDEX (origin 'c'), not auto-generated ones
      if (index.origin === "c") {
        const { rows: indexInfo } = await sql`
          SELECT * FROM pragma_index_info(${index.name})
        `
          .$castTo<SQLiteIndexInfo>()
          .execute(db);

        indexes.push({
          table: table.name,
          name: index.name,
          columns: indexInfo.map((info) => info.name),
          unique: index.unique === 1,
        });
      }
    }
  }

  return indexes;
};

type SQLiteIndexList = {
  seq: number;
  name: string;
  unique: number;
  origin: string;
  partial: number;
};

type SQLiteIndexInfo = {
  seqno: number;
  cid: number;
  name: string;
};

export const introspectSQLiteConstraints = async (db: PlannableKysely) => {
  const { rows: tables } = await sql`
    SELECT name FROM sqlite_master 
    WHERE type = 'table' 
    AND name NOT LIKE 'sqlite_%'
    AND name != 'kysely_migration'
    AND name != 'kysely_migration_lock'
  `
    .$castTo<{ name: string }>()
    .execute(db);

  const primaryKeys = [];
  const uniqueConstraints: ReadonlyArray<any> = [];
  const foreignKeys: any[] = [];

  for (const table of tables) {
    // Get primary key information
    const { rows: tableInfo } = await sql`
      SELECT * FROM pragma_table_info(${table.name})
    `
      .$castTo<SQLiteColumnInfo>()
      .execute(db);

    const pkColumns = tableInfo
      .filter((col) => col.pk > 0)
      .sort((a, b) => a.pk - b.pk)
      .map((col) => col.name);

    if (pkColumns.length > 0) {
      primaryKeys.push({
        schema: "main",
        table: table.name,
        name: `${table.name}_primary_key`,
        type: "PRIMARY KEY" as const,
        columns: pkColumns,
      });
    }

    // Get foreign key information
    const { rows: fkList } = await sql`
      SELECT * FROM pragma_foreign_key_list(${table.name})
    `
      .$castTo<SQLiteForeignKey>()
      .execute(db);

    // Group foreign keys by id
    const fkGroups = fkList.reduce(
      (acc, fk) => {
        if (!acc[fk.id]) acc[fk.id] = [];
        acc[fk.id].push(fk);
        return acc;
      },
      {} as Record<number, SQLiteForeignKey[]>
    );

    Object.values(fkGroups).forEach((group) => {
      foreignKeys.push({
        schema: "main",
        table: table.name,
        name: `fk_${table.name}_${group[0].table}`,
        type: "FOREIGN KEY" as const,
        columns: group.map((fk) => fk.from),
        referencedTable: group[0].table,
        referencedColumns: group.map((fk) => fk.to),
        onDelete: mapSQLiteAction(group[0].on_delete),
        onUpdate: mapSQLiteAction(group[0].on_update),
      });
    });
  }

  return {
    primaryKey: primaryKeys,
    unique: uniqueConstraints,
    foreignKey: foreignKeys,
  };
};

type SQLiteForeignKey = {
  id: number;
  seq: number;
  table: string;
  from: string;
  to: string;
  on_update: string;
  on_delete: string;
  match: string;
};

const mapSQLiteAction = (action: string): ReferentialActions | undefined => {
  const actionMap: Record<string, ReferentialActions> = {
    CASCADE: "cascade",
    "SET NULL": "set null",
    "SET DEFAULT": "set default",
    RESTRICT: "restrict",
    "NO ACTION": "no action",
  };

  return actionMap[action.toUpperCase()];
};
