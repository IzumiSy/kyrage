import { ColumnDataType } from "kysely";
import { constraintNaming } from "../naming";
import {
  ColumnValue,
  IndexSchema,
  DatabaseValue,
  DevDatabaseValue,
} from "./loader";
import {
  PrimaryKeyConstraintSchema,
  UniqueConstraintSchema,
  ReferentialActions,
  ForeignKeyConstraintSchema,
} from "../operations/shared/types";

/**
 * Defines a column in a table.
 */
export const column = (
  type: ColumnDataType,
  options?: Partial<Omit<ColumnValue, "type">>
) => ({
  type,
  notNull: options?.notNull,
  primaryKey: options?.primaryKey,
  unique: options?.unique,
  defaultSql: options?.defaultSql,
});

type DefinedValue<T, K extends string> = Omit<T, "table"> & {
  kind: K;
};
type DefinedColumn = ReturnType<typeof column>;
type DefinedIndex = DefinedValue<IndexSchema, "index">;
type DefinedPrimaryKeyConstraint = DefinedValue<
  PrimaryKeyConstraintSchema,
  "primaryKey"
>;
type DefinedUniqueConstraint = DefinedValue<UniqueConstraintSchema, "unique">;

type DefinedForeignKeyConstraint = {
  kind: "foreignKey";
  name: string;
  columns: ReadonlyArray<string>;
  referencedTable: string;
  referencedColumns: ReadonlyArray<string>;
  onDelete?: ReferentialActions;
  onUpdate?: ReferentialActions;
};

type ExpressionBuilders<T extends Record<string, DefinedColumn>> = {
  /**
   * Creates an index on the specified columns.
   *
   * The default is non-unique, and name is autogenerated by joining the column names and table name.
   */
  index: (
    columns: ReadonlyArray<string & keyof T>,
    options?: {
      name?: string;
      unique?: boolean;
    }
  ) => DefinedIndex;

  /**
   * Creates a primary key constraint on the specified columns.
   *
   * The default name is autogenerated by joining the column names and table name.
   */
  primaryKey: (
    columns: ReadonlyArray<string & keyof T>,
    options?: {
      name?: string;
    }
  ) => DefinedPrimaryKeyConstraint;

  /**
   * Creates a unique constraint on the specified columns.
   *
   * The default name is autogenerated by joining the column names and table name.
   */
  unique: (
    columns: ReadonlyArray<string & keyof T>,
    options?: {
      name?: string;
    }
  ) => DefinedUniqueConstraint;

  /**
   * Creates a foreign key constraint on the specified columns.
   *
   * The default name is autogenerated by joining the column names and table name.
   */
  reference: <R extends Record<string, DefinedColumn>>(
    columns: ReadonlyArray<string & keyof T> | (string & keyof T),
    referencedTable: { tableName: string; columns: R },
    referencedColumns: ReadonlyArray<string & keyof R> | (string & keyof R),
    options?: {
      name?: string;
      onDelete?: ReferentialActions;
      onUpdate?: ReferentialActions;
    }
  ) => DefinedForeignKeyConstraint;
};

/**
 * Defines a table with its columns and optional expression builders.
 */
export const defineTable = <T extends Record<string, DefinedColumn>>(
  /**
   * The name of the table.
   */
  name: string,

  /**
   * The columns in the table.
   */
  columns: T,

  /**
   * The expression builders for the table.
   *
   * This is where you can define additional indexes, constraints, or other
   * database-specific features for the table.
   */
  tableExpBuilder?: (
    builder: ExpressionBuilders<T>
  ) => ReadonlyArray<
    | ReturnType<ExpressionBuilders<T>["index"]>
    | ReturnType<ExpressionBuilders<T>["primaryKey"]>
    | ReturnType<ExpressionBuilders<T>["unique"]>
    | ReturnType<ExpressionBuilders<T>["reference"]>
  >
) => {
  const ensureNotEmptyColumns = (columns: ReadonlyArray<string>) => {
    if (columns.length === 0) {
      throw new Error("At least one column must be specified.");
    }
  };
  const createAutogenName = (
    prefix: string,
    columnNames: ReadonlyArray<string>
  ) => `${prefix}_${name}_${columnNames.join("_")}`;

  const builtConstraints = tableExpBuilder
    ? tableExpBuilder({
        index: (columns, options) => {
          ensureNotEmptyColumns(columns);
          return {
            kind: "index" as const,
            name: options?.name ?? createAutogenName("idx", columns),
            columns,
            unique: options?.unique ?? false,
          };
        },
        primaryKey: (columns, options) => {
          ensureNotEmptyColumns(columns);
          return {
            kind: "primaryKey" as const,
            name: options?.name ?? createAutogenName("pk", columns),
            columns,
          };
        },
        unique: (columns, options) => {
          ensureNotEmptyColumns(columns);
          return {
            kind: "unique" as const,
            name: options?.name ?? createAutogenName("uq", columns),
            columns,
          };
        },
        reference: (columns, referencedTable, referencedColumns, options) => {
          const normalizedColumns = Array.isArray(columns)
            ? columns
            : [columns];
          const normalizedReferencedColumns = Array.isArray(referencedColumns)
            ? referencedColumns
            : [referencedColumns];

          ensureNotEmptyColumns(normalizedColumns);
          ensureNotEmptyColumns(normalizedReferencedColumns);
          return {
            kind: "foreignKey" as const,
            name:
              options?.name ??
              constraintNaming.foreignKey(name, normalizedColumns),
            columns: normalizedColumns,
            referencedTable: referencedTable.tableName,
            referencedColumns: normalizedReferencedColumns,
            onDelete: options?.onDelete,
            onUpdate: options?.onUpdate,
          };
        },
      })
    : [];

  return {
    tableName: name,
    columns,
    indexes: builtConstraints.filter((c) => c.kind === ("index" as const)),
    primaryKeys: builtConstraints.filter(
      (c) => c.kind === ("primaryKey" as const)
    ),
    uniques: builtConstraints.filter((c) => c.kind === ("unique" as const)),
    foreignKeys: builtConstraints.filter(
      (c) => c.kind === ("foreignKey" as const)
    ),
  };
};

export type DefinedTable = ReturnType<typeof defineTable> & {
  indexes: ReadonlyArray<DefinedIndex>;
  primaryKeys: ReadonlyArray<DefinedPrimaryKeyConstraint>;
  uniques: ReadonlyArray<DefinedUniqueConstraint>;
  foreignKeys: ReadonlyArray<DefinedForeignKeyConstraint>;
};
export type DefinedTables = ReadonlyArray<DefinedTable>;

export type DefineConfigProp = {
  database: DatabaseValue;
  dev?: DevDatabaseValue;
  tables: DefinedTables;
};

export const defineConfig = (config: DefineConfigProp) => {
  const indexMap = new Map<string, IndexSchema>();
  const primaryKeyMap = new Map<string, PrimaryKeyConstraintSchema>();
  const uniqueMap = new Map<string, UniqueConstraintSchema>();
  const foreignKeyMap = new Map<string, ForeignKeyConstraintSchema>();

  for (const t of config.tables) {
    const tableName = t.tableName;

    for (const ix of t.indexes ?? []) {
      indexMap.set(`${tableName}:${ix.name}`, {
        table: tableName,
        name: ix.name,
        columns: ix.columns,
        unique: ix.unique,
      });
    }

    for (const pk of t.primaryKeys ?? []) {
      primaryKeyMap.set(`${tableName}:${pk.name}`, {
        table: tableName,
        name: pk.name,
        columns: pk.columns,
      });
    }

    for (const uq of t.uniques ?? []) {
      uniqueMap.set(`${tableName}:${uq.name}`, {
        table: tableName,
        name: uq.name,
        columns: uq.columns,
      });
    }

    for (const fk of t.foreignKeys ?? []) {
      foreignKeyMap.set(`${tableName}:${fk.name}`, {
        table: tableName,
        name: fk.name,
        columns: fk.columns,
        referencedTable: fk.referencedTable,
        referencedColumns: fk.referencedColumns,
        onDelete: fk.onDelete,
        onUpdate: fk.onUpdate,
      });
    }

    // カラム定義から暗黙的constraintを自動生成
    for (const [columnName, columnDef] of Object.entries(t.columns)) {
      // primaryKey: true の場合、primary key constraintを自動生成
      if (columnDef.primaryKey) {
        const constraintName = constraintNaming.primaryKey(tableName, [
          columnName,
        ]);
        const key = `${tableName}:${constraintName}`;

        // 明示的に定義されていない場合のみ追加
        if (!primaryKeyMap.has(key)) {
          primaryKeyMap.set(key, {
            table: tableName,
            name: constraintName,
            columns: [columnName],
          });
        }
      }

      // unique: true の場合、unique constraintを自動生成
      if (columnDef.unique) {
        const constraintName = constraintNaming.unique(tableName, [columnName]);
        const key = `${tableName}:${constraintName}`;

        // 明示的に定義されていない場合のみ追加
        if (!uniqueMap.has(key)) {
          uniqueMap.set(key, {
            table: tableName,
            name: constraintName,
            columns: [columnName],
          });
        }
      }
    }
  }

  return {
    ...config,
    dev: config.dev,
    indexes: Array.from(indexMap.values()),
    primaryKeyConstraints: Array.from(primaryKeyMap.values()),
    uniqueConstraints: Array.from(uniqueMap.values()),
    foreignKeyConstraints: Array.from(foreignKeyMap.values()),
  } as const;
};
