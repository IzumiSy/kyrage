import { ColumnValue, DatabaseValue } from "../schema";
import { ColumnDataType } from "kysely";
import { constraintNaming } from "../naming";

/**
 * Defines a column in a table.
 */
export const column = (
  type: ColumnDataType,
  options?: Partial<Omit<ColumnValue, "type">>
) => ({
  type,
  notNull: options?.notNull,
  primaryKey: options?.primaryKey,
  unique: options?.unique,
  defaultSql: options?.defaultSql,
});

type DefinedColumn = ReturnType<typeof column>;

type DefinedIndex = {
  kind: "index";
  name: string;
  columns: string[];
  unique: boolean;
};

type DefinedPrimaryKeyConstraint = {
  kind: "primaryKey";
  name: string;
  columns: string[];
};

type DefinedUniqueConstraint = {
  kind: "unique";
  name: string;
  columns: string[];
};

type DefinedForeignKeyConstraint = {
  kind: "foreignKey";
  name: string;
  columns: string[];
  referencedTable: string;
  referencedColumns: string[];
  onDelete?: "cascade" | "set null" | "set default" | "restrict" | "no action";
  onUpdate?: "cascade" | "set null" | "set default" | "restrict" | "no action";
};

type ExpressionBuilders<T extends Record<string, DefinedColumn>> = {
  /**
   * Creates an index on the specified columns.
   *
   * The default is non-unique, and name is autogenerated by joining the column names and table name.
   */
  index: (
    columns: Array<string & keyof T>,
    options?: {
      name?: string;
      unique?: boolean;
    }
  ) => DefinedIndex;

  /**
   * Creates a primary key constraint on the specified columns.
   *
   * The default name is autogenerated by joining the column names and table name.
   */
  primaryKey: (
    columns: Array<string & keyof T>,
    options?: {
      name?: string;
    }
  ) => DefinedPrimaryKeyConstraint;

  /**
   * Creates a unique constraint on the specified columns.
   *
   * The default name is autogenerated by joining the column names and table name.
   */
  unique: (
    columns: Array<string & keyof T>,
    options?: {
      name?: string;
    }
  ) => DefinedUniqueConstraint;

  /**
   * Creates a foreign key constraint on the specified columns.
   *
   * The default name is autogenerated by joining the column names and table name.
   */
  reference: <R extends Record<string, DefinedColumn>>(
    columns: Array<string & keyof T> | (string & keyof T),
    referencedTable: { tableName: string; columns: R },
    referencedColumns: Array<string & keyof R> | (string & keyof R),
    options?: {
      name?: string;
      onDelete?:
        | "cascade"
        | "set null"
        | "set default"
        | "restrict"
        | "no action";
      onUpdate?:
        | "cascade"
        | "set null"
        | "set default"
        | "restrict"
        | "no action";
    }
  ) => DefinedForeignKeyConstraint;
};

/**
 * Defines a table with its columns and optional expression builders.
 */
export const defineTable = <T extends Record<string, DefinedColumn>>(
  /**
   * The name of the table.
   */
  name: string,

  /**
   * The columns in the table.
   */
  columns: T,

  /**
   * The expression builders for the table.
   *
   * This is where you can define additional indexes, constraints, or other
   * database-specific features for the table.
   */
  tableExpBuilder?: (
    builder: ExpressionBuilders<T>
  ) => Array<
    | ReturnType<ExpressionBuilders<T>["index"]>
    | ReturnType<ExpressionBuilders<T>["primaryKey"]>
    | ReturnType<ExpressionBuilders<T>["unique"]>
    | ReturnType<ExpressionBuilders<T>["reference"]>
  >
) => {
  const ensureNotEmptyColumns = (columns: string[]) => {
    if (columns.length === 0) {
      throw new Error("At least one column must be specified.");
    }
  };
  const createAutogenName = (prefix: string, columnNames: string[]) =>
    `${prefix}_${name}_${columnNames.join("_")}`;

  const builtConstraints = tableExpBuilder
    ? tableExpBuilder({
        index: (columns, options) => {
          ensureNotEmptyColumns(columns);
          return {
            kind: "index" as const,
            name: options?.name ?? createAutogenName("idx", columns),
            columns,
            unique: options?.unique ?? false,
          };
        },
        primaryKey: (columns, options) => {
          ensureNotEmptyColumns(columns);
          return {
            kind: "primaryKey" as const,
            name: options?.name ?? createAutogenName("pk", columns),
            columns,
          };
        },
        unique: (columns, options) => {
          ensureNotEmptyColumns(columns);
          return {
            kind: "unique" as const,
            name: options?.name ?? createAutogenName("uq", columns),
            columns,
          };
        },
        reference: (columns, referencedTable, referencedColumns, options) => {
          const normalizedColumns = Array.isArray(columns)
            ? columns
            : [columns];
          const normalizedReferencedColumns = Array.isArray(referencedColumns)
            ? referencedColumns
            : [referencedColumns];

          ensureNotEmptyColumns(normalizedColumns);
          ensureNotEmptyColumns(normalizedReferencedColumns);
          return {
            kind: "foreignKey" as const,
            name:
              options?.name ??
              constraintNaming.foreignKey(name, normalizedColumns),
            columns: normalizedColumns,
            referencedTable: referencedTable.tableName,
            referencedColumns: normalizedReferencedColumns,
            onDelete: options?.onDelete,
            onUpdate: options?.onUpdate,
          };
        },
      })
    : [];

  return {
    tableName: name,
    columns,
    indexes: builtConstraints.filter((c) => c.kind === ("index" as const)),
    primaryKeys: builtConstraints.filter(
      (c) => c.kind === ("primaryKey" as const)
    ),
    uniques: builtConstraints.filter((c) => c.kind === ("unique" as const)),
    foreignKeys: builtConstraints.filter(
      (c) => c.kind === ("foreignKey" as const)
    ),
  };
};

export type DefinedTable = ReturnType<typeof defineTable> & {
  indexes: DefinedIndex[];
  primaryKeys: DefinedPrimaryKeyConstraint[];
  uniques: DefinedUniqueConstraint[];
  foreignKeys: DefinedForeignKeyConstraint[];
};
export type DefinedTables = Array<DefinedTable>;

export type DefineConfigProp = {
  database: DatabaseValue;
  tables: DefinedTables;
};

export const defineConfig = (config: DefineConfigProp) => {
  const indexMap = new Map<
    string,
    { table: string; name: string; columns: string[]; unique: boolean }
  >();

  const primaryKeyMap = new Map<
    string,
    { table: string; name: string; columns: string[] }
  >();

  const uniqueMap = new Map<
    string,
    { table: string; name: string; columns: string[] }
  >();

  const foreignKeyMap = new Map<
    string,
    {
      table: string;
      name: string;
      columns: string[];
      referencedTable: string;
      referencedColumns: string[];
      onDelete?:
        | "cascade"
        | "set null"
        | "set default"
        | "restrict"
        | "no action";
      onUpdate?:
        | "cascade"
        | "set null"
        | "set default"
        | "restrict"
        | "no action";
    }
  >();

  for (const t of config.tables) {
    const tableName = t.tableName;
    const indexes: DefinedIndex[] = t.indexes ?? [];
    const primaryKeys: DefinedPrimaryKeyConstraint[] = t.primaryKeys ?? [];
    const uniques: DefinedUniqueConstraint[] = t.uniques ?? [];

    for (const ix of indexes) {
      indexMap.set(`${tableName}:${ix.name}`, {
        table: tableName,
        name: ix.name,
        columns: ix.columns,
        unique: ix.unique,
      });
    }

    for (const pk of primaryKeys) {
      primaryKeyMap.set(`${tableName}:${pk.name}`, {
        table: tableName,
        name: pk.name,
        columns: pk.columns,
      });
    }

    for (const uq of uniques) {
      uniqueMap.set(`${tableName}:${uq.name}`, {
        table: tableName,
        name: uq.name,
        columns: uq.columns,
      });
    }

    for (const fk of t.foreignKeys ?? []) {
      foreignKeyMap.set(`${tableName}:${fk.name}`, {
        table: tableName,
        name: fk.name,
        columns: fk.columns,
        referencedTable: fk.referencedTable,
        referencedColumns: fk.referencedColumns,
        onDelete: fk.onDelete,
        onUpdate: fk.onUpdate,
      });
    }

    // カラム定義から暗黙的constraintを自動生成
    for (const [columnName, columnDef] of Object.entries(t.columns)) {
      // primaryKey: true の場合、primary key constraintを自動生成
      if (columnDef.primaryKey) {
        const constraintName = constraintNaming.primaryKey(tableName, [
          columnName,
        ]);
        const key = `${tableName}:${constraintName}`;

        // 明示的に定義されていない場合のみ追加
        if (!primaryKeyMap.has(key)) {
          primaryKeyMap.set(key, {
            table: tableName,
            name: constraintName,
            columns: [columnName],
          });
        }
      }

      // unique: true の場合、unique constraintを自動生成
      if (columnDef.unique) {
        const constraintName = constraintNaming.unique(tableName, [columnName]);
        const key = `${tableName}:${constraintName}`;

        // 明示的に定義されていない場合のみ追加
        if (!uniqueMap.has(key)) {
          uniqueMap.set(key, {
            table: tableName,
            name: constraintName,
            columns: [columnName],
          });
        }
      }
    }
  }

  return {
    ...config,
    indexes: Array.from(indexMap.values()),
    primaryKeyConstraints: Array.from(primaryKeyMap.values()),
    uniqueConstraints: Array.from(uniqueMap.values()),
    foreignKeyConstraints: Array.from(foreignKeyMap.values()),
  } as const;
};
