import { ColumnValue, DatabaseValue } from "../schema";
import { ColumnDataType } from "kysely";

/**
 * Defines a column in a table.
 */
export const column = (
  type: ColumnDataType,
  options?: Partial<Omit<ColumnValue, "type">>
) => ({
  type,
  notNull: options?.notNull,
  primaryKey: options?.primaryKey,
  unique: options?.unique,
  defaultSql: options?.defaultSql,
});

type DefinedColumn = ReturnType<typeof column>;

type DefinedIndex = {
  kind: "index";
  name: string;
  columns: string[];
  unique: boolean;
};

type DefinedPrimaryKeyConstraint = {
  kind: "primaryKey";
  name: string;
  columns: string[];
};

type DefinedUniqueConstraint = {
  kind: "unique";
  name: string;
  columns: string[];
};

type ExpressionBuilders<T extends Record<string, DefinedColumn>> = {
  /**
   * Creates an index on the specified columns.
   *
   * The default is non-unique, and name is autogenerated by joining the column names and table name.
   */
  index: (
    columns: Array<keyof T>,
    options?: {
      name?: string;
      unique?: boolean;
    }
  ) => DefinedIndex;

  /**
   * Creates a primary key constraint on the specified columns.
   *
   * The default name is autogenerated by joining the column names and table name.
   */
  primaryKey: (
    columns: Array<keyof T>,
    options?: {
      name?: string;
    }
  ) => DefinedPrimaryKeyConstraint;

  /**
   * Creates a unique constraint on the specified columns.
   *
   * The default name is autogenerated by joining the column names and table name.
   */
  unique: (
    columns: Array<keyof T>,
    options?: {
      name?: string;
    }
  ) => DefinedUniqueConstraint;
};

/**
 * Defines a table with its columns and optional expression builders.
 */
export const defineTable = <T extends Record<string, DefinedColumn>>(
  /**
   * The name of the table.
   */
  name: string,

  /**
   * The columns in the table.
   */
  columns: T,

  /**
   * The expression builders for the table.
   *
   * This is where you can define additional indexes, constraints, or other
   * database-specific features for the table.
   */
  tableExpBuilder?: (
    builder: ExpressionBuilders<T>
  ) => Array<
    | ReturnType<ExpressionBuilders<T>["index"]>
    | ReturnType<ExpressionBuilders<T>["primaryKey"]>
    | ReturnType<ExpressionBuilders<T>["unique"]>
  >
) => {
  const indexBuilder: ExpressionBuilders<T>["index"] = (cols, options) => {
    const columnNames = cols.map(String);
    return {
      kind: "index",
      name: options?.name ?? `idx_${name}_${columnNames.join("_")}`,
      columns: columnNames,
      unique: options?.unique ?? false,
    };
  };

  const primaryKeyBuilder: ExpressionBuilders<T>["primaryKey"] = (
    cols,
    options
  ) => {
    const columnNames = cols.map(String);
    return {
      kind: "primaryKey",
      name: options?.name ?? `pk_${name}_${columnNames.join("_")}`,
      columns: columnNames,
    };
  };

  const uniqueBuilder: ExpressionBuilders<T>["unique"] = (cols, options) => {
    const columnNames = cols.map(String);
    return {
      kind: "unique",
      name: options?.name ?? `uq_${name}_${columnNames.join("_")}`,
      columns: columnNames,
    };
  };

  const builtConstraints = tableExpBuilder
    ? tableExpBuilder({
        index: indexBuilder,
        primaryKey: primaryKeyBuilder,
        unique: uniqueBuilder,
      })
    : [];

  const indexes = builtConstraints.filter(
    (c) => c.kind === "index"
  ) as DefinedIndex[];
  const primaryKeys = builtConstraints.filter(
    (c) => c.kind === "primaryKey"
  ) as DefinedPrimaryKeyConstraint[];
  const uniques = builtConstraints.filter(
    (c) => c.kind === "unique"
  ) as DefinedUniqueConstraint[];

  return {
    tableName: name,
    columns,
    indexes,
    primaryKeys,
    uniques,
  };
};

export type DefinedTable = ReturnType<typeof defineTable> & {
  indexes: DefinedIndex[];
  primaryKeys: DefinedPrimaryKeyConstraint[];
  uniques: DefinedUniqueConstraint[];
};
export type DefinedTables = Array<DefinedTable>;

export type DefineConfigProp = {
  database: DatabaseValue;
  tables: DefinedTables;
};

export const defineConfig = (config: DefineConfigProp) => {
  const indexMap = new Map<
    string,
    { table: string; name: string; columns: string[]; unique: boolean }
  >();

  const primaryKeyMap = new Map<
    string,
    { table: string; name: string; columns: string[] }
  >();

  const uniqueMap = new Map<
    string,
    { table: string; name: string; columns: string[] }
  >();

  for (const t of config.tables) {
    const tableName = t.tableName;
    const indexes: DefinedIndex[] = t.indexes ?? [];
    const primaryKeys: DefinedPrimaryKeyConstraint[] = t.primaryKeys ?? [];
    const uniques: DefinedUniqueConstraint[] = t.uniques ?? [];

    for (const ix of indexes) {
      indexMap.set(`${tableName}:${ix.name}`, {
        table: tableName,
        name: ix.name,
        columns: ix.columns,
        unique: ix.unique,
      });
    }

    for (const pk of primaryKeys) {
      primaryKeyMap.set(`${tableName}:${pk.name}`, {
        table: tableName,
        name: pk.name,
        columns: pk.columns,
      });
    }

    for (const uq of uniques) {
      uniqueMap.set(`${tableName}:${uq.name}`, {
        table: tableName,
        name: uq.name,
        columns: uq.columns,
      });
    }
  }

  return {
    ...config,
    indexes: Array.from(indexMap.values()),
    primaryKeyConstraints: Array.from(primaryKeyMap.values()),
    uniqueConstraints: Array.from(uniqueMap.values()),
  } as const;
};
